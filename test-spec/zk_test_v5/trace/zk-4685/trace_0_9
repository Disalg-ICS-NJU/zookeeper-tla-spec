---------------- MODULE /usr/src/Project/output/model_simulation_2023-05-21_10-04-03_1/trace_0_9 -----------------
STATE_1 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ doInit = FALSE
/\ electing = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ recorder = [ pc |-> <<"Init">>,
  nConsequentFailure |-> 0,
  nCrash |-> 0,
  nPartition |-> 0,
  maxEpoch |-> 0,
  noExecute |-> {},
  nTimeout |-> 0,
  nTransaction |-> 0,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 0 @@ s1 :> 0 @@ s2 :> 0)
/\ connecting = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ proposalMsgsLog = {}
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 0 @@ s1 :> 0 @@ s2 :> 0)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 0 @@ s1 :> 0 @@ s2 :> 0)
/\ leaderOracle = NullPoint
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<>>
/\ epochLeader = <<{}, {}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_2 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s2 :> {} )
/\ zabState = (s0 :> BROADCAST @@ s1 :> BROADCAST @@ s2 :> BROADCAST)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<[mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102]>> @@
        s2 :> <<[mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102]>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ recorder = [ nPartition |-> 0,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 0,
  nCrash |-> 0,
  nTransaction |-> 2,
  maxEpoch |-> 1,
  pc |-> <<"SetInitState", s0, {s1, s2}>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 1 @@ s2 :> 1)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 1 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 0 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_3 == 
/\ forwarding = (s0 :> {s1} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s2 :> {} )
/\ zabState = (s0 :> BROADCAST @@ s1 :> BROADCAST @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<[mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102]>> @@
        s2 :> <<>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ recorder = [ nPartition |-> 1,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"PartitionStart", {s0, s2}>>},
  nTimeout |-> 1,
  nCrash |-> 0,
  nTransaction |-> 2,
  maxEpoch |-> 1,
  pc |-> <<"PartitionStart", s0, s2>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 1 @@ s2 :> 1)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 1 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 0 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> TRUE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_4 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 2,
  noExecute |->
      {<<"PartitionStart", {s0, s1}>>, <<"PartitionStart", {s0, s2}>>},
  nTimeout |-> 2,
  nCrash |-> 0,
  nTransaction |-> 2,
  maxEpoch |-> 1,
  pc |-> <<"PartitionStart", s0, s1>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 1 @@ s2 :> 1)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 1 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 0 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_5 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 2,
  nCrash |-> 0,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"ElectionAndDiscovery", s1, {s2}>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 2)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {s1, s2} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LEADING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> s1)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_6 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s1>>},
  nTimeout |-> 3,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"NodeCrash", s1>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 2)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> OFFLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_7 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 2,
  noExecute |-> {<<"NodeCrash", s0>>, <<"NodeCrash", s1>>, <<"NodeStart", s0>>},
  nTimeout |-> 3,
  nCrash |-> 2,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"NodeCrash", s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 2)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> OFFLINE @@ s1 :> OFFLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_8 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 2,
  noExecute |-> {<<"NodeCrash", s0>>, <<"NodeCrash", s1>>, <<"NodeStart", s0>>},
  nTimeout |-> 3,
  nCrash |-> 2,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"NodeStart", s1>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 2)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 2 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> OFFLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_9 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {<<"NodeCrash", s0>>},
  nTimeout |-> 3,
  nCrash |-> 2,
  nTransaction |-> 2,
  maxEpoch |-> 3,
  pc |-> <<"ElectionAndDiscovery", s1, {s2}>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 3 @@ s2 :> 3)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 3 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {s1, s2} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 3 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> OFFLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LEADING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> s1)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {}, {}, {}, {}, {}, {}, {}>>


STATE_10 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s0>>, <<"NodeCrash", s2>>},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 3,
  pc |-> <<"NodeCrash", s2>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 3 @@ s2 :> 3)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 3 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 3 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> OFFLINE @@ s1 :> ONLINE @@ s2 :> OFFLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {}, {}, {}, {}, {}, {}, {}>>


STATE_11 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s0>>, <<"NodeCrash", s2>>},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 3,
  pc |-> <<"NodeStart", s2>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 3 @@ s2 :> 3)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 3 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 3 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> OFFLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {}, {}, {}, {}, {}, {}, {}>>


STATE_12 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {<<"NodeCrash", s0>>},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"ElectionAndDiscovery", s1, {s2}>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 4)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {s1, s2} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> OFFLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LEADING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> s1)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {}, {}, {}, {}, {}, {}>>


STATE_13 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s0>>, <<"NodeCrash", s1>>},
  nTimeout |-> 5,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"NodeCrash", s1>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 4)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> OFFLINE @@ s1 :> OFFLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {}, {}, {}, {}, {}, {}>>


STATE_14 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s0>>, <<"NodeCrash", s1>>},
  nTimeout |-> 5,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"NodeStart", s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 4)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> OFFLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> TRUE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {}, {}, {}, {}, {}, {}>>


STATE_15 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s0>>, <<"NodeCrash", s1>>},
  nTimeout |-> 5,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"PartitionRecover", s0, s2>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 4)
/\ connecting = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 1 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s1
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> OFFLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> FALSE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :>
      { [connected |-> FALSE, sid |-> s2],
        [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {}, {}, {}, {}, {}, {}>>


STATE_16 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> ELECTION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {<<"NodeCrash", s1>>},
  nTimeout |-> 5,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 5,
  pc |-> <<"ElectionAndDiscovery", s0, {s2}>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 5)
/\ connecting = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s2]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> OFFLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> LOOKING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> FALSE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {}, {}, {}, {}, {}>>


STATE_17 == 
/\ forwarding = (s0 :> {s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s2}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> ELECTION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<>> @@
        s2 :>
            << [mtype |-> DIFF, mzxid |-> <<1, 1>>],
               [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<5, 0>>] >> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {<<"NodeCrash", s1>>},
  nTimeout |-> 5,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 5,
  pc |-> <<"LeaderSyncFollower", s0, s2>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 5)
/\ connecting = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s2]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> OFFLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> LOOKING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> FALSE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {}, {}, {}, {}, {}>>


STATE_18 == 
/\ forwarding = (s0 :> {s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s2}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> ELECTION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<>> @@
        s2 :>
            << [mtype |-> DIFF, mzxid |-> <<1, 1>>],
               [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<5, 0>>] >> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {<<"NodeCrash", s1>>},
  nTimeout |-> 5,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 5,
  pc |-> <<"NodeStart", s1>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 5)
/\ connecting = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s2]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> LOOKING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> TRUE @@ s2 :> FALSE) @@
  s1 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {}, {}, {}, {}, {}>>


STATE_19 == 
/\ forwarding = (s0 :> {s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s2}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> ELECTION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<>> @@
        s2 :>
            << [mtype |-> DIFF, mzxid |-> <<1, 1>>],
               [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<5, 0>>] >> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {<<"NodeCrash", s1>>},
  nTimeout |-> 5,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 5,
  pc |-> <<"PartitionRecover", s0, s1>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 5)
/\ connecting = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s2]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> LOOKING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {}, {}, {}, {}, {}>>


STATE_20 == 
/\ forwarding = (s0 :> {s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s2}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> ELECTION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<>> @@
        s2 :>
            << [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<5, 0>>] >> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {<<"NodeCrash", s1>>},
  nTimeout |-> 5,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 5,
  pc |-> <<"FollowerProcessSyncMessage", s2, s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 5)
/\ connecting = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s2]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> LOOKING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {}, {}, {}, {}, {}>>


STATE_21 == 
/\ forwarding = (s0 :> {s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s2}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> ELECTION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<>> @@
        s2 :>
            << [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<5, 0>>] >> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {<<"NodeCrash", s1>>},
  nTimeout |-> 5,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 5,
  pc |-> <<"FollowerProcessPROPOSALInSync", s2, s0, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 5)
/\ connecting = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s2]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> LOOKING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 5, ackSid |-> {}]>>,
        committed |-> <<>> ] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {}, {}, {}, {}, {}>>


STATE_22 == 
/\ forwarding = (s0 :> {s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s2}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> ELECTION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<>> @@
        s2 :> <<[mtype |-> NEWLEADER, mzxid |-> <<5, 0>>]>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {<<"NodeCrash", s1>>},
  nTimeout |-> 5,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 5,
  pc |-> <<"FollowerProcessCOMMITInSync", s2, s0, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 5)
/\ connecting = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s2]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> LOOKING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 5, ackSid |-> {}]>>,
        committed |-> <<<<1, 2>>>> ] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {}, {}, {}, {}, {}>>


STATE_23 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s2}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"PartitionStart", {s0, s2}>>, <<"NodeCrash", s1>>},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 5,
  pc |-> <<"PartitionStart", s0, s2>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 5)
/\ connecting = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s2]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> TRUE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> TRUE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {}, {}, {}, {}, {}>>


STATE_24 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s2}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> ELECTION @@ s1 :> ELECTION @@ s2 :> ELECTION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"PartitionStart", {s0, s2}>>, <<"NodeCrash", s1>>},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 5,
  pc |-> <<"PartitionRecover", s0, s2>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 5)
/\ connecting = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s2]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 5 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LOOKING @@ s1 :> LOOKING @@ s2 :> LOOKING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> NullPoint @@ s2 :> NullPoint)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {}, {}, {}, {}, {}>>


STATE_25 == 
/\ forwarding = (s0 :> {} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"ElectionAndDiscovery", s0, {s1, s2}>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_26 == 
/\ forwarding = (s0 :> {s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s2}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<>> @@
        s2 :>
            << [mtype |-> DIFF, mzxid |-> <<1, 1>>],
               [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"LeaderSyncFollower", s0, s2>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_27 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :>
            << [mtype |-> DIFF, mzxid |-> <<1, 1>>],
               [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> @@
        s2 :>
            << [mtype |-> DIFF, mzxid |-> <<1, 1>>],
               [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"LeaderSyncFollower", s0, s1>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_28 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :>
            << [mtype |-> DIFF, mzxid |-> <<1, 1>>],
               [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> @@
        s2 :>
            << [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessSyncMessage", s2, s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_29 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :>
            << [mtype |-> DIFF, mzxid |-> <<1, 1>>],
               [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> @@
        s2 :>
            << [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessPROPOSALInSync", s2, s0, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<>> ] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_30 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :>
            << [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> @@
        s2 :>
            << [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessSyncMessage", s1, s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<>> ] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_31 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :>
            << [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> @@
        s2 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessCOMMITInSync", s2, s0, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<<<1, 2>>>> ] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_32 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :>
            << [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<6, 0>>] >> @@
        s2 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessPROPOSALInSync", s1, s0, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<>> ] @@
  s2 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<<<1, 2>>>> ] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_33 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> @@
        s2 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessCOMMITInSync", s1, s0, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 1)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<<<1, 2>>>> ] @@
  s2 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<<<1, 2>>>> ] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_34 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = ( s0 :> <<>> @@
  s1 :> <<>> @@
  s2 :> <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>> )
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> @@
        s2 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessNEWLEADER", s2, s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<<<1, 2>>>> ] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_35 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> @@
        s2 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :>
      ( s0 :> <<[mtype |-> ACK, mzxid |-> <<1, 2>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerSyncProcessorLogRequest", s2, s0, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<<<1, 2>>>> ] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_36 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> @@
        s2 :> <<>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :>
      ( s0 :>
            << [mtype |-> ACK, mzxid |-> <<1, 2>>],
               [mtype |-> ACKLD, mzxid |-> <<6, 0>>] >> @@
        s1 :> <<>> @@
        s2 :> <<>> ) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessNEWLEADERAfterCurrentEpochUpdated", s2, s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> TRUE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<<<1, 2>>>> ] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_37 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> @@
        s2 :> <<>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :>
      ( s0 :> <<[mtype |-> ACKLD, mzxid |-> <<6, 0>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FilterNonexistentMessage", s0, s2>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>>,
        committed |-> <<<<1, 2>>>> ] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_38 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>> @@
  s2 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<6, 0>>]>> @@
        s2 :> <<>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :>
      ( s0 :> <<[mtype |-> ACKLD, mzxid |-> <<6, 0>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessNEWLEADER", s1, s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_39 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = ( s0 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}]>> @@
  s2 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :>
      ( s0 :> <<[mtype |-> ACKLD, mzxid |-> <<6, 0>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) @@
  s2 :>
      ( s0 :> <<[mtype |-> ACKLD, mzxid |-> <<6, 0>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessNEWLEADERAfterCurrentEpochUpdated", s1, s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_40 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :>
      ( s0 :>
            << [mtype |-> ACKLD, mzxid |-> <<6, 0>>],
               [mtype |-> ACK, mzxid |-> <<1, 2>>] >> @@
        s1 :> <<>> @@
        s2 :> <<>> ) @@
  s2 :>
      ( s0 :> <<[mtype |-> ACKLD, mzxid |-> <<6, 0>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerSyncProcessorLogRequest", s1, s0, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}]>>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_41 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<[mtype |-> UPTODATE, mzxid |-> <<6, 0>>]>> @@
        s2 :> <<>> ) @@
  s1 :>
      ( s0 :> <<[mtype |-> ACK, mzxid |-> <<1, 2>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) @@
  s2 :>
      ( s0 :> <<[mtype |-> ACKLD, mzxid |-> <<6, 0>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"LeaderProcessACKLD", s0, s1>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s1]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}],
   [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_42 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> BROADCAST @@ s1 :> BROADCAST @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :>
      ( s0 :> <<[mtype |-> ACK, mzxid |-> <<1, 2>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) @@
  s2 :>
      ( s0 :> <<[mtype |-> ACKLD, mzxid |-> <<6, 0>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessUPTODATE", s1, s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<<<1, 2>>>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s1]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}],
   [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_43 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> BROADCAST @@ s1 :> BROADCAST @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<>> @@
        s2 :> <<[mtype |-> UPTODATE, mzxid |-> <<6, 0>>]>> ) @@
  s1 :>
      ( s0 :> <<[mtype |-> ACK, mzxid |-> <<1, 2>>]>> @@
        s1 :> <<>> @@
        s2 :> <<>> ) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"LeaderProcessACKLD", s0, s2>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<<<1, 2>>>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s1]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}],
   [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_44 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           epoch |-> 1,
           ackSid |-> {s0, s1} ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> BROADCAST @@ s1 :> BROADCAST @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 1>>, index |-> 1] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<>> @@
        s2 :> <<[mtype |-> UPTODATE, mzxid |-> <<6, 0>>]>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"LeaderProcessACK", s0, s1, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<<<1, 2>>>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s1]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}],
   [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0, s1}] >>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_45 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           epoch |-> 1,
           ackSid |-> {s0, s1} ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> BROADCAST @@ s1 :> BROADCAST @@ s2 :> SYNCHRONIZATION)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :>
      ( s0 :> <<>> @@
        s1 :> <<>> @@
        s2 :> <<[mtype |-> UPTODATE, mzxid |-> <<6, 0>>]>> ) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerCommitProcessorCommit", s1, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s1]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}],
   [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0, s1}] >>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_46 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           epoch |-> 1,
           ackSid |-> {s0, s1} ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> BROADCAST @@ s1 :> BROADCAST @@ s2 :> BROADCAST)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s2 :> [zxid |-> <<1, 1>>, index |-> 1] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerProcessUPTODATE", s2, s0>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s2 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<<<1, 2>>>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s1]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}],
   [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0, s1}] >>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


STATE_47 == 
/\ forwarding = (s0 :> {s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ history = ( s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           epoch |-> 1,
           ackSid |-> {s0, s1} ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 6, ackSid |-> {}] >> )
/\ doInit = TRUE
/\ electing = ( s0 :>
      { [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :>
      { [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s2, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s2 :> {} )
/\ zabState = (s0 :> BROADCAST @@ s1 :> BROADCAST @@ s2 :> BROADCAST)
/\ queuedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  prefixConsistency |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  primaryOrder |-> TRUE,
  monotonicRead |-> TRUE,
  processConsistency |-> TRUE,
  leaderLogCompleteness |-> TRUE,
  committedLogDurability |-> TRUE ]
/\ lastProcessed = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s2 :> [zxid |-> <<1, 2>>, index |-> 2] )
/\ rcvBuffer = ( s0 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s1 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) @@
  s2 :> (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>) )
/\ initialHistory = ( s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0}],
         [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0}] >> @@
  s1 :> <<[zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s1}]>> @@
  s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           epoch |-> 1,
           ackSid |-> {s0, s1, s2} ] >> )
/\ recorder = [ nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 6,
  nCrash |-> 4,
  nTransaction |-> 2,
  maxEpoch |-> 6,
  pc |-> <<"FollowerCommitProcessorCommit", s2, <<1, 2>>>>,
  nClientRequest |-> 0 ]
/\ acceptedEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ connecting = ( s0 :>
      { [connected |-> TRUE, sid |-> s0],
        [connected |-> TRUE, sid |-> s1],
        [connected |-> TRUE, sid |-> s2] } @@
  s1 :> {[connected |-> TRUE, sid |-> s1], [connected |-> TRUE, sid |-> s2]} @@
  s2 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, data |-> 101, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 1, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 5, data |-> 102, source |-> s0],
  [zxid |-> <<1, 2>>, epoch |-> 6, data |-> 102, source |-> s0] }
/\ lastCommitted = ( s0 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s1 :> [zxid |-> <<1, 2>>, index |-> 2] @@
  s2 :> [zxid |-> <<1, 2>>, index |-> 2] )
/\ daInv = [ stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE,
  messageLegal |-> FALSE ]
/\ currentEpoch = (s0 :> 6 @@ s1 :> 6 @@ s2 :> 6)
/\ learners = (s0 :> {s0, s1, s2} @@ s1 :> {} @@ s2 :> {})
/\ tempMaxEpoch = (s0 :> 6 @@ s1 :> 4 @@ s2 :> 0)
/\ leaderOracle = s0
/\ committedRequests = (s0 :> <<>> @@ s1 :> <<>> @@ s2 :> <<>>)
/\ status = (s0 :> ONLINE @@ s1 :> ONLINE @@ s2 :> ONLINE)
/\ state = (s0 :> LEADING @@ s1 :> FOLLOWING @@ s2 :> FOLLOWING)
/\ partition = ( s0 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s1 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) @@
  s2 :> (s0 :> FALSE @@ s1 :> FALSE @@ s2 :> FALSE) )
/\ packetsSync = ( s0 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s2 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s0 :> {[connected |-> TRUE, sid |-> s0], [connected |-> TRUE, sid |-> s1]} @@
  s1 :> {[connected |-> TRUE, sid |-> s1]} @@
  s2 :> {} )
/\ leaderAddr = (s0 :> NullPoint @@ s1 :> s0 @@ s2 :> s0)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, epoch |-> 1, ackSid |-> {s0, s1, s2}],
   [zxid |-> <<1, 2>>, value |-> 102, epoch |-> 1, ackSid |-> {s0, s1}] >>
/\ epochLeader = <<{s0}, {s1}, {s1}, {s1}, {s0}, {s0}, {}, {}, {}, {}>>


=================================================
